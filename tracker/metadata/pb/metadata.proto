syntax = "proto3";
package metadata.pb;

service MatadataService {

    rpc MkFolder(MkFolderReq)returns(MkFolderResp){}

    rpc CheckFileExist(CheckFileExistReq)returns(CheckFileExistResp){}

    rpc UploadFilePrepare(UploadFilePrepareReq) returns (UploadFilePrepareResp){}// only use for Erasure Code store type

    rpc UploadFileDone(UploadFileDoneReq) returns (UploadFileDoneResp){}

    rpc ListFiles(ListFilesReq) returns (ListFilesResp){}

    rpc RetrieveFile(RetrieveFileReq) returns (RetrieveFileResp){}

    rpc Remove(RemoveReq) returns (RemoveResp){}

}

message MkFolderReq{
    uint32 version =1;
    bytes nodeId=2;
    uint64 timestamp=3;
    string path=4;//parent path in net disk
    repeated string folder=5;
    bytes sign=6;
}

message MkFolderResp{
    uint32 code = 1;//0:success, 1: failed
    string errMsg=2;  
}

message CheckFileExistReq {
    uint32 version =1;
    bytes nodeId=2;
    uint64 timestamp=3;
    string filePath=4;//file parent path in net disk
    bytes fileHash=5;
    uint64 fileSize=6;
    string fileName=7;
    uint64 fileModTime=8;
    bytes fileData=9;//file content if file size less than or equal 8k
    bool interactive=10;//if false, will auto add suffix timestamp when exists same name file
    bool newVersion=11;
    bytes sign=12;
}

message CheckFileExistResp{
    uint32 code = 1;//0:if file exists or save tiny file success; 1: please read storeType to go step 2 or step 3; 2 and more than 2 are kinds of errors
    string errMsg=2;
    FileStoreType storeType=3; // suggest store type, ErasureCode or MultiReplica
    int32 dataPieceCount=4;  // 0 if not ErasureCode
    int32 verifyPieceCount=5; // 0 if not ErasureCode
    int32 replicaCount=6;  // 0 if not MultiReplica
    repeated ReplicaProvider provider=7;// if use MultiReplica, size is more than replicaCount
}

enum FileStoreType{
    ErasureCode=0;
    MultiReplica=1;
}

message ReplicaProvider{
    bytes nodeId=1;
    string server=2;
    uint32 port=3;
    uint64 timestamp=4;
    string ticket=5;
    bytes auth=6;
}

message UploadFilePrepareReq{
    uint32 version =1;
    bytes nodeId=2;
    uint64 timestamp=3;
    bytes fileHash=4;
    uint64 fileSize=5;
    repeated PieceHashAndSize piece=6;
    bytes sign=7;
}

message PieceHashAndSize{
    bytes hash=1;
    uint32 size=2;
}

message UploadFilePrepareResp{
    repeated ErasureCodeProvider provider=1;
}

message ErasureCodeProvider{
    bytes nodeId=1;
    string server=2;
    uint32 port=3;
    uint64 timestamp=4;
    repeated PieceHashAuth hashAuth=5;// part of provider have mutiple hashAuth,  They are standby provider for multiple piece.
}

message PieceHashAuth{
    bytes hash=1;
    string ticket=2;
    bytes auth=3;
}

message UploadFileDoneReq{
    uint32 version =1;
    bytes nodeId=2;
    uint64 timestamp=3;
    string filePath=4;//file parent path in net disk
    bytes fileHash=5;
    uint64 fileSize=6;
    string fileName=7;
    uint64 fileModTime=8;
    repeated Partition partition=9;// size is one if use MultiReplica
    bool interactive=10;//if false, will auto add suffix timestamp when exists same name file 
    bool newVersion=11;
    bytes sign=12;
}

message Partition{
    repeated Block block=1;  //size is one if use MultiReplica
}

message Block{
    bytes hash=1;
    uint32 size=2;
    uint32 blockSeq=3;
    bool checksum=4;
    repeated bytes storeNodeId=5;
}

message UploadFileDoneResp{
    uint32 code = 1;//0:success, 1: failed
    string errMsg=2;
}

message ListFilesReq{
    uint32 version =1;
    bytes nodeId=2;
    uint64 timestamp=3;
    string path=4;// nil if top level
    uint32 pageSize=5;//can not more than 2000
    uint32 pageNum=6;// 1-based
    SortType sortType=7;
    bool ascOrder=8;
    bytes sign=9;
}

enum SortType{
    Name=0;
    ModTime=1;
    Size=2;
}

message ListFilesResp{
    uint32 code = 1;//0:success, 1: failed
    string errMsg=2;
    uint32 totalRecord=3;
    repeated FileOrFolder fof=4;
}

message FileOrFolder{
    bool folder=1;
    string name=2;
    uint64 modTime=3;
    bytes fileHash=4;//nil if folder
    uint64 fileSize=5;//0 if folder
}

message RetrieveFileReq{
    uint32 version =1;
    bytes nodeId=2;
    uint64 timestamp=3;
    bytes fileHash=4;
    uint64 fileSize=5;
    bytes sign=6;
}

message RetrieveFileResp{
    uint32 code = 1;//0:success, 1: failed
    string errMsg=2;
    bytes fileData=3;// not nil if tiny file
    repeated Partition partition=4;// nil if tiny file
}

message RemoveReq{
    uint32 version =1;
    bytes nodeId=2;
    uint64 timestamp=3;
    string path=4;
    bool recursive=5;
    bytes sign=6;
}

message RemoveResp{
    uint32 code = 1;//0:success, 1: failed
    string errMsg=2;
}